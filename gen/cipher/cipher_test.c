#include <assert.h>
#include <string.h>

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#include "aes.h"
#include "des_bit.h"
#include "des.h"

#ifdef NDEBUG
    #error This test program must work with macro "ASSERT" enabled!
#endif

//------------------------------------------------------------------------------
//---- AES Test Functions ------------------------------------------------------
//------------------------------------------------------------------------------
void aes_key_expansion_test(void)
{
    static const byte_t key128[] =
    {
        0x2B,0x7E,0x15,0x16, 0x28,0xAE,0xD2,0xA6, 0xAB,0xF7,0x15,0x88, 0x09,0xCF,0x4F,0x3C
    };

    static const byte_t roundkey128[] =
    {
        0x2B,0x7E,0x15,0x16, 0x28,0xAE,0xD2,0xA6, 0xAB,0xF7,0x15,0x88, 0x09,0xCF,0x4F,0x3C,
        0xA0,0xFA,0xFE,0x17, 0x88,0x54,0x2C,0xB1, 0x23,0xA3,0x39,0x39, 0x2A,0x6C,0x76,0x05,
        0xF2,0xC2,0x95,0xF2, 0x7A,0x96,0xB9,0x43, 0x59,0x35,0x80,0x7A, 0x73,0x59,0xF6,0x7F,
        0x3D,0x80,0x47,0x7D, 0x47,0x16,0xFE,0x3E, 0x1E,0x23,0x7E,0x44, 0x6D,0x7A,0x88,0x3B,
        0xEF,0x44,0xA5,0x41, 0xA8,0x52,0x5B,0x7F, 0xB6,0x71,0x25,0x3B, 0xDB,0x0B,0xAD,0x00,
        0xD4,0xD1,0xC6,0xF8, 0x7C,0x83,0x9D,0x87, 0xCA,0xF2,0xB8,0xBC, 0x11,0xF9,0x15,0xBC,
        0x6D,0x88,0xA3,0x7A, 0x11,0x0B,0x3E,0xFD, 0xDB,0xF9,0x86,0x41, 0xCA,0x00,0x93,0xFD,
        0x4E,0x54,0xF7,0x0E, 0x5F,0x5F,0xC9,0xF3, 0x84,0xA6,0x4F,0xB2, 0x4E,0xA6,0xDC,0x4F,
        0xEA,0xD2,0x73,0x21, 0xB5,0x8D,0xBA,0xD2, 0x31,0x2B,0xF5,0x60, 0x7F,0x8D,0x29,0x2F,
        0xAC,0x77,0x66,0xF3, 0x19,0xFA,0xDC,0x21, 0x28,0xD1,0x29,0x41, 0x57,0x5C,0x00,0x6E,
        0xD0,0x14,0xF9,0xA8, 0xC9,0xEE,0x25,0x89, 0xE1,0x3F,0x0C,0xC8, 0xB6,0x63,0x0C,0xA6
    };

    static const byte_t key192[] =
    {
        0x8E,0x73,0xB0,0xF7, 0xDA,0x0E,0x64,0x52, 0xC8,0x10,0xF3,0x2B, 0x80,0x90,0x79,0xE5,
        0x62,0xF8,0xEA,0xD2, 0x52,0x2C,0x6B,0x7B
    };

    static const byte_t roundkey192[] =
    {
        0x8E,0x73,0xB0,0xF7, 0xDA,0x0E,0x64,0x52, 0xC8,0x10,0xF3,0x2B, 0x80,0x90,0x79,0xE5,
        0x62,0xF8,0xEA,0xD2, 0x52,0x2C,0x6B,0x7B, 0xFE,0x0C,0x91,0xF7, 0x24,0x02,0xF5,0xA5,
        0xEC,0x12,0x06,0x8E, 0x6C,0x82,0x7F,0x6B, 0x0E,0x7A,0x95,0xB9, 0x5C,0x56,0xFE,0xC2,
        0x4D,0xB7,0xB4,0xBD, 0x69,0xB5,0x41,0x18, 0x85,0xA7,0x47,0x96, 0xE9,0x25,0x38,0xFD,
        0xE7,0x5F,0xAD,0x44, 0xBB,0x09,0x53,0x86, 0x48,0x5A,0xF0,0x57, 0x21,0xEF,0xB1,0x4F,
        0xA4,0x48,0xF6,0xD9, 0x4D,0x6D,0xCE,0x24, 0xAA,0x32,0x63,0x60, 0x11,0x3B,0x30,0xE6,
        0xA2,0x5E,0x7E,0xD5, 0x83,0xB1,0xCF,0x9A, 0x27,0xF9,0x39,0x43, 0x6A,0x94,0xF7,0x67,
        0xC0,0xA6,0x94,0x07, 0xD1,0x9D,0xA4,0xE1, 0xEC,0x17,0x86,0xEB, 0x6F,0xA6,0x49,0x71,
        0x48,0x5F,0x70,0x32, 0x22,0xCB,0x87,0x55, 0xE2,0x6D,0x13,0x52, 0x33,0xF0,0xB7,0xB3,
        0x40,0xBE,0xEB,0x28, 0x2F,0x18,0xA2,0x59, 0x67,0x47,0xD2,0x6B, 0x45,0x8C,0x55,0x3E,
        0xA7,0xE1,0x46,0x6C, 0x94,0x11,0xF1,0xDF, 0x82,0x1F,0x75,0x0A, 0xAD,0x07,0xD7,0x53,
        0xCA,0x40,0x05,0x38, 0x8F,0xCC,0x50,0x06, 0x28,0x2D,0x16,0x6A, 0xBC,0x3C,0xE7,0xB5,
        0xE9,0x8B,0xA0,0x6F, 0x44,0x8C,0x77,0x3C, 0x8E,0xCC,0x72,0x04, 0x01,0x00,0x22,0x02
    };

    static const byte_t key256[] =
    {
        0x60,0x3D,0xEB,0x10, 0x15,0xCA,0x71,0xBE, 0x2B,0x73,0xAE,0xF0, 0x85,0x7D,0x77,0x81,
        0x1F,0x35,0x2C,0x07, 0x3B,0x61,0x08,0xD7, 0x2D,0x98,0x10,0xA3, 0x09,0x14,0xDF,0xF4
    };

    static const byte_t roundkey256[] =
    {
        0x60,0x3D,0xEB,0x10, 0x15,0xCA,0x71,0xBE, 0x2B,0x73,0xAE,0xF0, 0x85,0x7D,0x77,0x81,
        0x1F,0x35,0x2C,0x07, 0x3B,0x61,0x08,0xD7, 0x2D,0x98,0x10,0xA3, 0x09,0x14,0xDF,0xF4,
        0x9B,0xA3,0x54,0x11, 0x8E,0x69,0x25,0xAF, 0xA5,0x1A,0x8B,0x5F, 0x20,0x67,0xFC,0xDE,
        0xA8,0xB0,0x9C,0x1A, 0x93,0xD1,0x94,0xCD, 0xBE,0x49,0x84,0x6E, 0xB7,0x5D,0x5B,0x9A,
        0xD5,0x9A,0xEC,0xB8, 0x5B,0xF3,0xC9,0x17, 0xFE,0xE9,0x42,0x48, 0xDE,0x8E,0xBE,0x96,
        0xB5,0xA9,0x32,0x8A, 0x26,0x78,0xA6,0x47, 0x98,0x31,0x22,0x29, 0x2F,0x6C,0x79,0xB3,
        0x81,0x2C,0x81,0xAD, 0xDA,0xDF,0x48,0xBA, 0x24,0x36,0x0A,0xF2, 0xFA,0xB8,0xB4,0x64,
        0x98,0xC5,0xBF,0xC9, 0xBE,0xBD,0x19,0x8E, 0x26,0x8C,0x3B,0xA7, 0x09,0xE0,0x42,0x14,
        0x68,0x00,0x7B,0xAC, 0xB2,0xDF,0x33,0x16, 0x96,0xE9,0x39,0xE4, 0x6C,0x51,0x8D,0x80,
        0xC8,0x14,0xE2,0x04, 0x76,0xA9,0xFB,0x8A, 0x50,0x25,0xC0,0x2D, 0x59,0xC5,0x82,0x39,
        0xDE,0x13,0x69,0x67, 0x6C,0xCC,0x5A,0x71, 0xFA,0x25,0x63,0x95, 0x96,0x74,0xEE,0x15,
        0x58,0x86,0xCA,0x5D, 0x2E,0x2F,0x31,0xD7, 0x7E,0x0A,0xF1,0xFA, 0x27,0xCF,0x73,0xC3,
        0x74,0x9C,0x47,0xAB, 0x18,0x50,0x1D,0xDA, 0xE2,0x75,0x7E,0x4F, 0x74,0x01,0x90,0x5A,
        0xCA,0xFA,0xAA,0xE3, 0xE4,0xD5,0x9B,0x34, 0x9A,0xDF,0x6A,0xCE, 0xBD,0x10,0x19,0x0D,
        0xFE,0x48,0x90,0xD1, 0xE6,0x18,0x8D,0x0B, 0x04,0x6D,0xF3,0x44, 0x70,0x6C,0x63,0x1E
    };

    aes_state_t buf[ sizeof(roundkey256) / sizeof(aes_state_t) ];

    assert( aes_key_expand(NULL, key128, sizeof(key128)) == sizeof(roundkey128)/sizeof(aes_state_t) );
    assert( aes_key_expand(buf , key128, sizeof(key128)) == sizeof(roundkey128)/sizeof(aes_state_t) );
    assert( 0 == memcmp(buf, roundkey128, sizeof(roundkey128)) );

    assert( aes_key_expand(NULL, key192, sizeof(key192)) == sizeof(roundkey192)/sizeof(aes_state_t) );
    assert( aes_key_expand(buf , key192, sizeof(key192)) == sizeof(roundkey192)/sizeof(aes_state_t) );
    assert( 0 == memcmp(buf, roundkey192, sizeof(roundkey192)) );

    assert( aes_key_expand(NULL, key256, sizeof(key256)) == sizeof(roundkey256)/sizeof(aes_state_t) );
    assert( aes_key_expand(buf , key256, sizeof(key256)) == sizeof(roundkey256)/sizeof(aes_state_t) );
    assert( 0 == memcmp(buf, roundkey256, sizeof(roundkey256)) );
}
//------------------------------------------------------------------------------
void aes_state_cipher_test(void)
{
    static const byte_t      key_128[]      = {   0x00,0x01,0x02,0x03, 0x04,0x05,0x06,0x07, 0x08,0x09,0x0A,0x0B, 0x0C,0x0D,0x0E,0x0F   };
    static const aes_state_t state_128_text = {{{ 0x00,0x11,0x22,0x33, 0x44,0x55,0x66,0x77, 0x88,0x99,0xAA,0xBB, 0xCC,0xDD,0xEE,0xFF }}};
    static const aes_state_t state_128_code = {{{ 0x69,0xC4,0xE0,0xD8, 0x6A,0x7B,0x04,0x30, 0xD8,0xCD,0xB7,0x80, 0x70,0xB4,0xC5,0x5A }}};
    static const byte_t      key_192[]      = {   0x00,0x01,0x02,0x03, 0x04,0x05,0x06,0x07, 0x08,0x09,0x0A,0x0B, 0x0C,0x0D,0x0E,0x0F,
                                                  0x10,0x11,0x12,0x13, 0x14,0x15,0x16,0x17 };
    static const aes_state_t state_192_text = {{{ 0x00,0x11,0x22,0x33, 0x44,0x55,0x66,0x77, 0x88,0x99,0xAA,0xBB, 0xCC,0xDD,0xEE,0xFF }}};
    static const aes_state_t state_192_code = {{{ 0xDD,0xA9,0x7C,0xA4, 0x86,0x4C,0xDF,0xE0, 0x6E,0xAF,0x70,0xA0, 0xEC,0x0D,0x71,0x91 }}};
    static const byte_t      key_256[]      = {   0x00,0x01,0x02,0x03, 0x04,0x05,0x06,0x07, 0x08,0x09,0x0A,0x0B, 0x0C,0x0D,0x0E,0x0F,
                                                  0x10,0x11,0x12,0x13, 0x14,0x15,0x16,0x17, 0x18,0x19,0x1A,0x1B, 0x1C,0x1D,0x1E,0x1F   };
    static const aes_state_t state_256_text = {{{ 0x00,0x11,0x22,0x33, 0x44,0x55,0x66,0x77, 0x88,0x99,0xAA,0xBB, 0xCC,0xDD,0xEE,0xFF }}};
    static const aes_state_t state_256_code = {{{ 0x8E,0xA2,0xB7,0xCA, 0x51,0x67,0x45,0xBF, 0xEA,0xFC,0x49,0x90, 0x4B,0x49,0x60,0x89 }}};
    size_t      rndkeys_cnt;
    aes_state_t rndkeys[20];
    aes_state_t state;

    // 128 bit key
    state = state_128_text;
    // - Key expansion
    rndkeys_cnt = aes_key_expand(rndkeys, key_128, sizeof(key_128));
    assert( rndkeys_cnt == 11 );
    // - Encipher
    aes_state_encipher(&state, rndkeys, rndkeys_cnt);
    assert( 0 == memcmp(&state, &state_128_code, sizeof(aes_state_t)) );
    // - Decipher
    aes_state_decipher(&state, rndkeys, rndkeys_cnt);
    assert( 0 == memcmp(&state, &state_128_text, sizeof(aes_state_t)) );

    // 192 bit key
    state = state_192_text;
    // - Key expansion
    rndkeys_cnt = aes_key_expand(rndkeys, key_192, sizeof(key_192));
    assert( rndkeys_cnt == 13 );
    // - Encipher
    aes_state_encipher(&state, rndkeys, rndkeys_cnt);
    assert( 0 == memcmp(&state, &state_192_code, sizeof(aes_state_t)) );
    // - Decipher
    aes_state_decipher(&state, rndkeys, rndkeys_cnt);
    assert( 0 == memcmp(&state, &state_192_text, sizeof(aes_state_t)) );

    // 256 bit key
    state = state_256_text;
    // - Key expansion
    rndkeys_cnt = aes_key_expand(rndkeys, key_256, sizeof(key_256));
    assert( rndkeys_cnt == 15 );
    // - Encipher
    aes_state_encipher(&state, rndkeys, rndkeys_cnt);
    assert( 0 == memcmp(&state, &state_256_code, sizeof(aes_state_t)) );
    // - Decipher
    aes_state_decipher(&state, rndkeys, rndkeys_cnt);
    assert( 0 == memcmp(&state, &state_256_text, sizeof(aes_state_t)) );
}
//------------------------------------------------------------------------------
void aes_multiblock_cipher_test(void)
{
    static const byte_t key     [] = { 0x00,0x01,0x02,0x03, 0x04,0x05,0x06,0x07, 0x08,0x09,0x0A,0x0B, 0x0C,0x0D,0x0E,0x0F };
    static const byte_t datatext[] = { 0x00,0x01,0x02,0x03, 0x04,0x05,0x06,0x07, 0x08,0x09,0x0A,0x0B, 0x0C,0x0D,0x0E,0x0F,
                                       0x10,0x11,0x12,0x13, 0x14,0x15,0x16,0x17, 0x18,0x19,0x1A,0x1B, 0x1C,0x1D,0x1E,0x1F,
                                       0x20,0x21,0x22,0x23, 0x24,0x25,0x26,0x17, 0x28,0x29,0x2A,0x2B, 0x2C,0x2D,0x2E,0x2F,
                                       0x30,0x31,0x32,0x33, 0x34,0x35,0x36,0x17, 0x38,0x39,0x3A,0x3B, 0x3C,0x3D,0x3E,0x3F,
                                       0x40,0x41,0x42,0x33, 0x44,0x45,0x46,0x47, 0x48,0x49,0x4A,0x4B };
    static const aes_state_t iv_zero      = {{{ 0x00,0x00,0x00,0x00,
                                                0x00,0x00,0x00,0x00,
                                                0x00,0x00,0x00,0x00,
                                                0x00,0x00,0x00,0x00 }}};
    static const aes_state_t iv_should_be = {{{ 0x10,0x13,0x16,0x19,
                                                0x1C,0x1F,0x22,0x25,
                                                0x28,0x2B,0x2E,0x31,
                                                0x34,0x17,0x3A,0x3D }}};
    aes_state_t iv;
    byte_t      databuf[80];


    // EBC mode test
    memset(databuf, 0, sizeof(databuf));
    // - Encipher test
    assert( sizeof(databuf) == aes_ecb_encipher(NULL   , datatext, sizeof(datatext), key, sizeof(key)) );
    assert( sizeof(databuf) == aes_ecb_encipher(databuf, datatext, sizeof(datatext), key, sizeof(key)) );
    assert( 0 != memcmp(databuf, datatext, sizeof(datatext)) );
    // - Decipher test
    assert( sizeof(databuf) == aes_ecb_decipher(NULL   , databuf, sizeof(databuf)+sizeof(aes_state_t)-1, key, sizeof(key)) );
    assert( sizeof(databuf) == aes_ecb_decipher(NULL   , databuf, sizeof(databuf), key, sizeof(key)) );
    assert( sizeof(databuf) == aes_ecb_decipher(databuf, databuf, sizeof(databuf), key, sizeof(key)) );
    assert( 0 == memcmp(databuf, datatext, sizeof(datatext)) );

    // CBC mode test
    memset(&iv, -1, sizeof(iv));
    // - Initialisation vector (IV) calculation test
    aes_cbc_get_initvec(&iv, datatext, 2*sizeof(aes_state_t));
    assert( 0 == memcmp(&iv, &iv_zero, sizeof(aes_state_t)) );
    aes_cbc_get_initvec(&iv, datatext, sizeof(datatext));
    assert( 0 == memcmp(&iv, &iv_should_be, sizeof(aes_state_t)) );
    // - Encipher test (auto IV)
    assert( sizeof(databuf) == aes_cbc_encipher(NULL   , datatext, sizeof(datatext), key, sizeof(key), NULL) );
    assert( sizeof(databuf) == aes_cbc_encipher(databuf, datatext, sizeof(datatext), key, sizeof(key), NULL) );
    assert( 0 != memcmp(databuf, datatext, sizeof(datatext)) );
    // - Decipher test (auto IV)
    assert( sizeof(databuf) == aes_cbc_decipher(NULL   , databuf, sizeof(databuf)+sizeof(aes_state_t)-1, key, sizeof(key), NULL) );
    assert( sizeof(databuf) == aes_cbc_decipher(NULL   , databuf, sizeof(databuf), key, sizeof(key), NULL) );
    assert( sizeof(databuf) == aes_cbc_decipher(databuf, databuf, sizeof(databuf), key, sizeof(key), NULL) );
    assert( 0 == memcmp(databuf, datatext, sizeof(datatext)) );
    // - Encipher test (manual IV)
    assert( sizeof(databuf) == aes_cbc_encipher(NULL   , datatext, sizeof(datatext), key, sizeof(key), &iv_zero) );
    assert( sizeof(databuf) == aes_cbc_encipher(databuf, datatext, sizeof(datatext), key, sizeof(key), &iv_zero) );
    assert( 0 != memcmp(databuf, datatext, sizeof(datatext)) );
    // - Decipher test (manual IV)
    assert( sizeof(databuf) == aes_cbc_decipher(NULL   , databuf, sizeof(databuf)+sizeof(aes_state_t)-1, key, sizeof(key), &iv_zero) );
    assert( sizeof(databuf) == aes_cbc_decipher(NULL   , databuf, sizeof(databuf), key, sizeof(key), &iv_zero) );
    assert( sizeof(databuf) == aes_cbc_decipher(databuf, databuf, sizeof(databuf), key, sizeof(key), &iv_zero) );
    assert( 0 == memcmp(databuf, datatext, sizeof(datatext)) );
}
//------------------------------------------------------------------------------
//---- DES Test Functions ------------------------------------------------------
//------------------------------------------------------------------------------
void des_bit_test(void)
{
    byte_t byte_0            = 0xD4;
    sbit_t byte_separated[8];
    sbit_t byte_permuted [8];
    sbit_t byte_shifted  [8];
    sbit_t byte_added    [8];
    int    permute_table [8] = {3,5,0,4,7,1,2,6};

    sbit_separate(byte_separated, byte_0);
    assert( byte_separated[0] == 1 );
    assert( byte_separated[1] == 1 );
    assert( byte_separated[2] == 0 );
    assert( byte_separated[3] == 1 );
    assert( byte_separated[4] == 0 );
    assert( byte_separated[5] == 1 );
    assert( byte_separated[6] == 0 );
    assert( byte_separated[7] == 0 );

    assert( byte_0 == sbit_combine(byte_separated) );

    sbit_permute(byte_permuted, 8, byte_separated, permute_table);
    assert( byte_permuted[0] == 1 );
    assert( byte_permuted[1] == 1 );
    assert( byte_permuted[2] == 1 );
    assert( byte_permuted[3] == 0 );
    assert( byte_permuted[4] == 0 );
    assert( byte_permuted[5] == 1 );
    assert( byte_permuted[6] == 0 );
    assert( byte_permuted[7] == 0 );

    memcpy(byte_shifted, byte_permuted, 8*sizeof(sbit_t));
    sbit_shift_left_1(byte_shifted, 8);
    assert( byte_shifted[0] == 1 );
    assert( byte_shifted[1] == 1 );
    assert( byte_shifted[2] == 0 );
    assert( byte_shifted[3] == 0 );
    assert( byte_shifted[4] == 1 );
    assert( byte_shifted[5] == 0 );
    assert( byte_shifted[6] == 0 );
    assert( byte_shifted[7] == 1 );

    sbit_xor(byte_added, byte_permuted, byte_shifted, 8);
    assert( byte_added[0] == 0 );
    assert( byte_added[1] == 0 );
    assert( byte_added[2] == 1 );
    assert( byte_added[3] == 0 );
    assert( byte_added[4] == 1 );
    assert( byte_added[5] == 1 );
    assert( byte_added[6] == 0 );
    assert( byte_added[7] == 1 );
}
//------------------------------------------------------------------------------
void des_key_expansion_test(void)
{
    static const byte_t mainkey[8] =
    {
        0x13, 0x34, 0x57, 0x79, 0x9B, 0xBC, 0xDF, 0xF1
    };
    static const des_subkey_t subkeys[16] =
    {
        {{ 0x1B, 0x02, 0xEF, 0xFC, 0x70, 0x72 }},
        {{ 0x79, 0xAE, 0xD9, 0xDB, 0xC9, 0xE5 }},
        {{ 0x55, 0xFC, 0x8A, 0x42, 0xCF, 0x99 }},
        {{ 0x72, 0xAD, 0xD6, 0xDB, 0x35, 0x1D }},
        {{ 0x7C, 0xEC, 0x07, 0xEB, 0x53, 0xA8 }},
        {{ 0x63, 0xA5, 0x3E, 0x50, 0x7B, 0x2F }},
        {{ 0xEC, 0x84, 0xB7, 0xF6, 0x18, 0xBC }},
        {{ 0xF7, 0x8A, 0x3A, 0xC1, 0x3B, 0xFB }},
        {{ 0xE0, 0xDB, 0xEB, 0xED, 0xE7, 0x81 }},
        {{ 0xB1, 0xF3, 0x47, 0xBA, 0x46, 0x4F }},
        {{ 0x21, 0x5F, 0xD3, 0xDE, 0xD3, 0x86 }},
        {{ 0x75, 0x71, 0xF5, 0x94, 0x67, 0xE9 }},
        {{ 0x97, 0xC5, 0xD1, 0xFA, 0xBA, 0x41 }},
        {{ 0x5F, 0x43, 0xB7, 0xF2, 0xE7, 0x3A }},
        {{ 0xBF, 0x91, 0x8D, 0x3D, 0x3F, 0x0A }},
        {{ 0xCB, 0x3D, 0x8B, 0x0E, 0x17, 0xF5 }}
    };

    static const byte_t tdea_key_1[24] =
    {
        0x1B, 0x02, 0xEF, 0xFC, 0x70, 0x72, 0x79, 0xAE,
        0xD9, 0xDB, 0xC9, 0xE5, 0x55, 0xFC, 0x8A, 0x42,
        0xCF, 0x99, 0x72, 0xAD, 0xD6, 0xDB, 0x35, 0x1D
    };
    static const byte_t tdea_key_2[16] =
    {
        0x1B, 0x02, 0xEF, 0xFC, 0x70, 0x72, 0x79, 0xAE,
        0xD9, 0xDB, 0xC9, 0xE5, 0x55, 0xFC, 0x8A, 0x42
    };
    static const byte_t tdea_key_3[8] =
    {
        0x1B, 0x02, 0xEF, 0xFC, 0x70, 0x72, 0x79, 0xAE
    };

    static const byte_t tdea_exp_1[24] =
    {
        0x1B, 0x02, 0xEF, 0xFC, 0x70, 0x72, 0x79, 0xAE,
        0xD9, 0xDB, 0xC9, 0xE5, 0x55, 0xFC, 0x8A, 0x42,
        0xCF, 0x99, 0x72, 0xAD, 0xD6, 0xDB, 0x35, 0x1D
    };
    static const byte_t tdea_exp_2[24] =
    {
        0x1B, 0x02, 0xEF, 0xFC, 0x70, 0x72, 0x79, 0xAE,
        0xD9, 0xDB, 0xC9, 0xE5, 0x55, 0xFC, 0x8A, 0x42,
        0x1B, 0x02, 0xEF, 0xFC, 0x70, 0x72, 0x79, 0xAE,
    };
    static const byte_t tdea_exp_3[24] =
    {
        0x1B, 0x02, 0xEF, 0xFC, 0x70, 0x72, 0x79, 0xAE,
        0x1B, 0x02, 0xEF, 0xFC, 0x70, 0x72, 0x79, 0xAE,
        0x1B, 0x02, 0xEF, 0xFC, 0x70, 0x72, 0x79, 0xAE
    };


    des_subkey_t subkeys_calc [16];
    byte_t       tdea_exp_calc[24];
    int          i;

    // DES key expansion test

    des_key_expand(subkeys_calc, mainkey);
    for(i=0; i<16; ++i)
        assert( 0 == memcmp(subkeys_calc[i].data, subkeys[i].data, sizeof(subkeys[i].data)) );

    // Triple-DES (TDEA) key expansion test

    tdea_key_expand(tdea_exp_calc, tdea_key_1, sizeof(tdea_key_1));
    assert( 0 == memcmp(tdea_exp_calc, tdea_exp_1, sizeof(tdea_exp_1)) );

    tdea_key_expand(tdea_exp_calc, tdea_key_2, sizeof(tdea_key_2));
    assert( 0 == memcmp(tdea_exp_calc, tdea_exp_2, sizeof(tdea_exp_2)) );

    tdea_key_expand(tdea_exp_calc, tdea_key_3, sizeof(tdea_key_3));
    assert( 0 == memcmp(tdea_exp_calc, tdea_exp_3, sizeof(tdea_exp_3)) );
}
//------------------------------------------------------------------------------
void des_block_cipher_test(void)
{
    static const byte_t key      [ 8] = { 0x13, 0x34, 0x57, 0x79, 0x9B, 0xBC, 0xDF, 0xF1 };
    static const byte_t key3     [24] = { 0x13, 0x34, 0x57, 0x79, 0x9B, 0xBC, 0xDF, 0xF1,
                                          0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
                                          0x85, 0xE8, 0x13, 0x54, 0x0F, 0x0A, 0xB4, 0x05 };
    static const byte_t source   [ 8] = { 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF };
    static const byte_t ciphered [ 8] = { 0x85, 0xE8, 0x13, 0x54, 0x0F, 0x0A, 0xB4, 0x05 };
    static const byte_t ciphered3[ 8] = { 0x89, 0x65, 0x97, 0xC0, 0x39, 0x8B, 0x57, 0x1A };

    byte_t block[8];

    // DES test

    memcpy(block, source, sizeof(source));
    des_block_encipher(block, key);
    assert( 0 == memcmp(block, ciphered, sizeof(ciphered)) );

    des_block_decipher(block, key);
    assert( 0 == memcmp(block, source, sizeof(source)) );

    // Triple-DES (TDEA) test

    memcpy(block, source, sizeof(source));
    tdea_block_encipher(block, key3);
    assert( 0 == memcmp(block, ciphered3, sizeof(ciphered3)) );

    tdea_block_decipher(block, key3);
    assert( 0 == memcmp(block, source, sizeof(source)) );
}
//------------------------------------------------------------------------------
void des_iv_test(void)
{
    static const unsigned blocksize = 8;
    static const byte_t text       [32] = { 0x13, 0x34, 0x57, 0x79, 0x9B, 0xBC, 0xDF, 0xF1,
                                            0x13, 0x34, 0x57, 0x79, 0x9B, 0xBC, 0xDF, 0xF1,
                                            0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
                                            0x85, 0xE8, 0x13, 0x54, 0x0F, 0x0A, 0xB4, 0x05 };
    static const byte_t iv_zero     [8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    static const byte_t iv_should_be[8] = { 0x13, 0x57, 0x9B, 0xDF, 0x01, 0x45, 0x89, 0xCD };
    byte_t iv[8];

    memset(iv, -1, sizeof(iv));

    tdea_cbc_get_initvec(iv, text, 2*blocksize);
    assert( 0 == memcmp(iv, iv_zero, blocksize) );

    tdea_cbc_get_initvec(iv, text, sizeof(text));
    assert( 0 == memcmp(iv, iv_should_be, blocksize) );
}
//------------------------------------------------------------------------------
void des_multiblock_cipher_test(void)
{
    static const byte_t iv      [ 8] = { 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88 };
    static const byte_t key     [24] = { 0x13, 0x34, 0x57, 0x79, 0x9B, 0xBC, 0xDF, 0xF1,
                                         0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
                                         0x85, 0xE8, 0x13, 0x54, 0x0F, 0x0A, 0xB4, 0x05 };
    static const byte_t source  [16] = { 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
                                         0x85, 0xE8, 0x13, 0x54, 0x0F, 0x0A, 0xB4, 0x05 };
    static const byte_t code_ecb[16] = { 0x89, 0x65, 0x97, 0xC0, 0x39, 0x8B, 0x57, 0x1A,
                                         0xF9, 0x79, 0x26, 0x57, 0x10, 0x81, 0x5F, 0xD3 };
    static const byte_t code_cbc[16] = { 0x77, 0x00, 0x9B, 0xC1, 0xB7, 0xB8, 0x48, 0x93,
                                         0x53, 0xE3, 0x24, 0x4B, 0xD8, 0x3F, 0xF0, 0x48 };

    byte_t data[16];

    // Triple_DES (TDEA) with ECB mode

    assert( sizeof(code_ecb) == tdea_ecb_encipher(NULL, source, sizeof(source), key, sizeof(key)) );
    assert( sizeof(code_ecb) == tdea_ecb_encipher(data, source, sizeof(source), key, sizeof(key)) );
    assert( 0 == memcmp(data, code_ecb, sizeof(code_ecb)) );

    assert( sizeof(source) == tdea_ecb_decipher(NULL, data, sizeof(data), key, sizeof(key)) );
    assert( sizeof(source) == tdea_ecb_decipher(data, data, sizeof(data), key, sizeof(key)) );
    assert( 0 == memcmp(data, source, sizeof(source)) );

    // Triple_DES (TDEA) with CBC mode

    assert( sizeof(code_cbc) == tdea_cbc_encipher(NULL, source, sizeof(source), key, sizeof(key), iv) );
    assert( sizeof(code_cbc) == tdea_cbc_encipher(data, source, sizeof(source), key, sizeof(key), iv) );
    assert( 0 == memcmp(data, code_cbc, sizeof(code_cbc)) );

    assert( sizeof(source) == tdea_cbc_decipher(NULL, data, sizeof(data), key, sizeof(key), iv) );
    assert( sizeof(source) == tdea_cbc_decipher(data, data, sizeof(data), key, sizeof(key), iv) );
    assert( 0 == memcmp(data, source, sizeof(source)) );
}
//------------------------------------------------------------------------------
//---- Main Test Function ------------------------------------------------------
//------------------------------------------------------------------------------
int main(int argc, char *argv[])
{
    aes_key_expansion_test();
    aes_private_debug_test();
    aes_state_cipher_test();
    aes_multiblock_cipher_test();

    des_bit_test();
    des_key_expansion_test();
    des_private_debug_test();
    des_block_cipher_test();
    des_iv_test();
    des_multiblock_cipher_test();

    return 0;
}
//------------------------------------------------------------------------------

